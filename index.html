"""
Telegram SoundCloud Clone Bot
–ü–æ–ª–Ω—ã–π –∞–≥—Ä–µ–≥–∞—Ç–æ—Ä –º—É–∑—ã–∫–∏ –∏–∑ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
"""

import asyncio
import sqlite3
import os
import yt_dlp
import requests
import json
import aiofiles
from datetime import datetime
from io import BytesIO
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass

from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, InputFile
from aiogram.client.session.aiohttp import AiohttpSession
import aiohttp

# ============= –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø =============
@dataclass
class Config:
    BOT_TOKEN: str = "8524841805:AAGnJNG8DDfOxc0Zyubzt1uEXNYe9sHLaCM"  # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω
    ADMIN_IDS: List[int] = None
    
    def __post_init__(self):
        if self.ADMIN_IDS is None:
            self.ADMIN_IDS = [6408686413]
        
        self.SOURCES = {
            "youtube": True,
            "soundgator": True,
            "bandcamp": True,
            "freemusicarchive": True,
            "jamendo": True,
            "musopen": True,
            "internet_archive": True,
        }
        
        self.SEARCH_LIMIT = 15
        self.MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB
        self.CACHE_DIR = "audio_cache"
        
config = Config()

# –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –∫—ç—à–∞
os.makedirs(config.CACHE_DIR, exist_ok=True)

# ============= –ë–ê–ó–ê –î–ê–ù–ù–´–• =============
class Database:
    def __init__(self, db_path="music_bot.db"):
        self.conn = sqlite3.connect(db_path, check_same_thread=False)
        self.create_tables()
    
    def create_tables(self):
        cursor = self.conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS tracks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                track_id TEXT UNIQUE,
                title TEXT,
                artist TEXT,
                duration INTEGER,
                source TEXT,
                source_url TEXT,
                audio_url TEXT,
                cover_url TEXT,
                genre TEXT,
                play_count INTEGER DEFAULT 0,
                download_count INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER UNIQUE,
                username TEXT,
                search_count INTEGER DEFAULT 0,
                last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS search_cache (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                query TEXT,
                results TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        self.conn.commit()
    
    def add_track(self, track_data: dict):
        cursor = self.conn.cursor()
        try:
            cursor.execute('''
                INSERT OR REPLACE INTO tracks 
                (track_id, title, artist, duration, source, source_url, audio_url, cover_url, genre)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                track_data['track_id'],
                track_data['title'],
                track_data['artist'],
                track_data['duration'],
                track_data['source'],
                track_data['source_url'],
                track_data['audio_url'],
                track_data['cover_url'],
                track_data.get('genre', 'Unknown')
            ))
            self.conn.commit()
            return cursor.lastrowid
        except Exception as e:
            print(f"Database error: {e}")
            return None
    
    def get_track(self, track_id: str):
        cursor = self.conn.cursor()
        cursor.execute('SELECT * FROM tracks WHERE track_id = ?', (track_id,))
        return cursor.fetchone()
    
    def increment_play_count(self, track_id: str):
        cursor = self.conn.cursor()
        cursor.execute('UPDATE tracks SET play_count = play_count + 1 WHERE track_id = ?', (track_id,))
        self.conn.commit()
    
    def increment_download_count(self, track_id: str):
        cursor = self.conn.cursor()
        cursor.execute('UPDATE tracks SET download_count = download_count + 1 WHERE track_id = ?', (track_id,))
        self.conn.commit()
    
    def add_user(self, user_id: int, username: str = None):
        cursor = self.conn.cursor()
        cursor.execute('''
            INSERT OR IGNORE INTO users (user_id, username) VALUES (?, ?)
        ''', (user_id, username))
        cursor.execute('''
            UPDATE users SET last_active = CURRENT_TIMESTAMP, username = ?
            WHERE user_id = ?
        ''', (username, user_id))
        self.conn.commit()
    
    def add_search_to_cache(self, query: str, results: list):
        cursor = self.conn.cursor()
        cursor.execute('''
            INSERT INTO search_cache (query, results)
            VALUES (?, ?)
        ''', (query, json.dumps(results)))
        self.conn.commit()
    
    def get_cached_search(self, query: str):
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT results FROM search_cache 
            WHERE query = ? AND datetime(created_at) > datetime('now', '-1 hour')
            ORDER BY id DESC LIMIT 1
        ''', (query,))
        result = cursor.fetchone()
        return json.loads(result[0]) if result else None

db = Database()

# ============= –ê–ì–†–ï–ì–ê–¢–û–† –ú–£–ó–´–ö–ò =============
class MusicAggregator:
    def __init__(self):
        self.session = aiohttp.ClientSession()
        self.ydl_opts = {
            'format': 'bestaudio/best',
            'quiet': True,
            'no_warnings': True,
            'extract_flat': True,
            'force_generic_extractor': False,
        }
    
    async def search_youtube(self, query: str, limit: int = 10) -> List[Dict]:
        """–ü–æ–∏—Å–∫ –Ω–∞ YouTube —á–µ—Ä–µ–∑ yt-dlp"""
        try:
            ydl = yt_dlp.YoutubeDL(self.ydl_opts)
            search_query = f"ytsearch{limit}:{query}"
            result = await asyncio.to_thread(
                ydl.extract_info, search_query, download=False
            )
            
            tracks = []
            if 'entries' in result:
                for entry in result['entries']:
                    if entry:
                        track = {
                            'track_id': f"youtube_{entry['id']}",
                            'title': entry.get('title', 'Unknown'),
                            'artist': entry.get('uploader', 'Unknown'),
                            'duration': entry.get('duration', 0),
                            'source': 'youtube',
                            'source_url': entry.get('webpage_url', ''),
                            'audio_url': None,  # –ë—É–¥–µ—Ç –ø–æ–ª—É—á–µ–Ω –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏
                            'cover_url': entry.get('thumbnail', ''),
                            'genre': 'YouTube Music'
                        }
                        tracks.append(track)
            return tracks
        except Exception as e:
            print(f"YouTube search error: {e}")
            return []
    
    async def search_soundgator(self, query: str, limit: int = 10) -> List[Dict]:
        """–ü–æ–∏—Å–∫ —á–µ—Ä–µ–∑ SoundGator (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Ç—Ä–µ–∫–∏)"""
        try:
            url = f"https://api.soundgator.com/v1/search"
            params = {
                'q': query,
                'limit': limit,
                'free': 'true'
            }
            
            async with self.session.get(url, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    tracks = []
                    for item in data.get('tracks', []):
                        track = {
                            'track_id': f"sg_{item['id']}",
                            'title': item.get('title', 'Unknown'),
                            'artist': item.get('artist', {}).get('name', 'Unknown'),
                            'duration': item.get('duration', 0),
                            'source': 'soundgator',
                            'source_url': item.get('permalink_url', ''),
                            'audio_url': item.get('stream_url', ''),
                            'cover_url': item.get('artwork_url', ''),
                            'genre': item.get('genre', 'Unknown')
                        }
                        tracks.append(track)
                    return tracks
                return []
        except:
            return []
    
    async def search_freemusicarchive(self, query: str, limit: int = 10) -> List[Dict]:
        """–ü–æ–∏—Å–∫ –≤ Free Music Archive"""
        try:
            url = "https://freemusicarchive.org/api/get/tracks.json"
            params = {
                'api_key': 'YOUR_API_KEY',  # –ü–æ–ª—É—á–∏—Ç–µ –Ω–∞ freemusicarchive.org
                'q': query,
                'limit': limit
            }
            
            async with self.session.get(url, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    tracks = []
                    for item in data.get('dataset', []):
                        track = {
                            'track_id': f"fma_{item['track_id']}",
                            'title': item.get('track_title', 'Unknown'),
                            'artist': item.get('artist_name', 'Unknown'),
                            'duration': int(item.get('track_duration', 0)),
                            'source': 'fma',
                            'source_url': item.get('track_url', ''),
                            'audio_url': item.get('track_file', ''),
                            'cover_url': item.get('track_image_file', ''),
                            'genre': item.get('genre_title', 'Unknown')
                        }
                        tracks.append(track)
                    return tracks
                return []
        except:
            return []
    
    async def search_jamendo(self, query: str, limit: int = 10) -> List[Dict]:
        """–ü–æ–∏—Å–∫ –Ω–∞ Jamendo (–±–µ—Å–ø–ª–∞—Ç–Ω–∞—è –º—É–∑—ã–∫–∞)"""
        try:
            url = "https://api.jamendo.com/v3.0/tracks/"
            params = {
                'client_id': 'YOUR_CLIENT_ID',  # –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –Ω–∞ jamendo.com
                'format': 'json',
                'search': query,
                'limit': limit,
                'audioformat': 'mp3'
            }
            
            async with self.session.get(url, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    tracks = []
                    for item in data.get('results', []):
                        track = {
                            'track_id': f"jam_{item['id']}",
                            'title': item.get('name', 'Unknown'),
                            'artist': item.get('artist_name', 'Unknown'),
                            'duration': item.get('duration', 0),
                            'source': 'jamendo',
                            'source_url': item.get('shareurl', ''),
                            'audio_url': item.get('audio', ''),
                            'cover_url': item.get('image', ''),
                            'genre': ' '.join(item.get('tags', {}).get('genres', []))
                        }
                        tracks.append(track)
                    return tracks
                return []
        except:
            return []
    
    async def search_internet_archive(self, query: str, limit: int = 10) -> List[Dict]:
        """–ü–æ–∏—Å–∫ –≤ Internet Archive"""
        try:
            url = "https://archive.org/advancedsearch.php"
            params = {
                'q': f'({query}) AND mediatype:audio',
                'fl[]': ['identifier', 'title', 'creator', 'runtime', 'downloads'],
                'sort[]': ['downloads desc'],
                'rows': limit,
                'page': 1,
                'output': 'json'
            }
            
            async with self.session.get(url, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    tracks = []
                    for item in data.get('response', {}).get('docs', []):
                        track = {
                            'track_id': f"ia_{item['identifier']}",
                            'title': item.get('title', 'Unknown'),
                            'artist': item.get('creator', 'Unknown')[0] if isinstance(item.get('creator'), list) else item.get('creator', 'Unknown'),
                            'duration': int(item.get('runtime', '0').split(':')[0]) * 60 if ':' in item.get('runtime', '0') else 0,
                            'source': 'internet_archive',
                            'source_url': f"https://archive.org/details/{item['identifier']}",
                            'audio_url': f"https://archive.org/download/{item['identifier']}/{item['identifier']}.mp3",
                            'cover_url': '',
                            'genre': 'Archive'
                        }
                        tracks.append(track)
                    return tracks
                return []
        except:
            return []
    
    async def aggregate_search(self, query: str, limit: int = 15) -> List[Dict]:
        """–ê–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–∏—Å–∫ –ø–æ –≤—Å–µ–º –∏—Å—Ç–æ—á–Ω–∏–∫–∞–º"""
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
        cached = db.get_cached_search(query)
        if cached:
            return cached[:limit]
        
        tasks = []
        if config.SOURCES.get("youtube"):
            tasks.append(self.search_youtube(query, limit))
        if config.SOURCES.get("soundgator"):
            tasks.append(self.search_soundgator(query, limit))
        if config.SOURCES.get("freemusicarchive"):
            tasks.append(self.search_freemusicarchive(query, limit))
        if config.SOURCES.get("jamendo"):
            tasks.append(self.search_jamendo(query, limit))
        if config.SOURCES.get("internet_archive"):
            tasks.append(self.search_internet_archive(query, limit))
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # –û–±—ä–µ–¥–∏–Ω—è–µ–º –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        all_tracks = []
        for result in results:
            if isinstance(result, list):
                all_tracks.extend(result)
        
        # –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã
        unique_tracks = []
        seen_ids = set()
        for track in all_tracks:
            if track['track_id'] not in seen_ids:
                seen_ids.add(track['track_id'])
                unique_tracks.append(track)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
        db.add_search_to_cache(query, unique_tracks[:limit])
        
        return unique_tracks[:limit]
    
    async def download_audio(self, track_data: Dict) -> Tuple[Optional[str], Optional[str]]:
        """–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞"""
        try:
            if track_data['source'] == 'youtube':
                # –î–ª—è YouTube –∏—Å–ø–æ–ª—å–∑—É–µ–º yt-dlp –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
                ydl_opts = {
                    'format': 'bestaudio/best',
                    'outtmpl': f"{config.CACHE_DIR}/%(id)s.%(ext)s",
                    'quiet': True,
                    'no_warnings': True,
                }
                
                ydl = yt_dlp.YoutubeDL(ydl_opts)
                info = await asyncio.to_thread(
                    ydl.extract_info, track_data['source_url'], download=True
                )
                
                # –ù–∞—Ö–æ–¥–∏–º —Å–∫–∞—á–∞–Ω–Ω—ã–π —Ñ–∞–π–ª
                downloaded_files = [f for f in os.listdir(config.CACHE_DIR) 
                                  if f.startswith(info['id'])]
                if downloaded_files:
                    file_path = os.path.join(config.CACHE_DIR, downloaded_files[0])
                    return file_path, info.get('title', 'Unknown')
            
            elif track_data['audio_url']:
                # –î–ª—è –¥—Ä—É–≥–∏—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —Å–∫–∞—á–∏–≤–∞–µ–º –Ω–∞–ø—Ä—è–º—É—é
                async with self.session.get(track_data['audio_url']) as response:
                    if response.status == 200:
                        file_ext = 'mp3'  # –∏–ª–∏ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏–∑ Content-Type
                        filename = f"{track_data['track_id']}.{file_ext}"
                        file_path = os.path.join(config.CACHE_DIR, filename)
                        
                        async with aiofiles.open(file_path, 'wb') as f:
                            await f.write(await response.read())
                        
                        return file_path, track_data['title']
            
            return None, None
        except Exception as e:
            print(f"Download error: {e}")
            return None, None

aggregator = MusicAggregator()

# ============= –¢–ï–õ–ï–ì–†–ê–ú –ë–û–¢ =============
bot = Bot(token=config.BOT_TOKEN)
dp = Dispatcher()

# ============= –ö–õ–ê–í–ò–ê–¢–£–†–´ =============
def get_search_keyboard(tracks: List[Dict], current_page: int = 0, per_page: int = 5) -> InlineKeyboardMarkup:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞"""
    start_idx = current_page * per_page
    end_idx = start_idx + per_page
    page_tracks = tracks[start_idx:end_idx]
    
    keyboard = []
    for i, track in enumerate(page_tracks, start=1):
        btn_text = f"{i}. {track['title'][:30]} - {track['artist'][:20]}"
        callback_data = f"track_{track['track_id']}"
        keyboard.append([InlineKeyboardButton(text=btn_text, callback_data=callback_data)])
    
    # –ö–Ω–æ–ø–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
    nav_buttons = []
    if current_page > 0:
        nav_buttons.append(InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=f"page_{current_page-1}"))
    
    if end_idx < len(tracks):
        nav_buttons.append(InlineKeyboardButton(text="–í–ø–µ—Ä–µ–¥ ‚ñ∂Ô∏è", callback_data=f"page_{current_page+1}"))
    
    if nav_buttons:
        keyboard.append(nav_buttons)
    
    keyboard.append([InlineKeyboardButton(text="üîç –ù–æ–≤—ã–π –ø–æ–∏—Å–∫", callback_data="new_search")])
    
    return InlineKeyboardMarkup(inline_keyboard=keyboard)

def get_track_keyboard(track_id: str) -> InlineKeyboardMarkup:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç—Ä–µ–∫–æ–º"""
    keyboard = [
        [
            InlineKeyboardButton(text="‚ñ∂Ô∏è –°–ª—É—à–∞—Ç—å", callback_data=f"play_{track_id}"),
            InlineKeyboardButton(text="‚¨áÔ∏è –°–∫–∞—á–∞—Ç—å", callback_data=f"download_{track_id}")
        ],
        [
            InlineKeyboardButton(text="üéµ –ü–æ—Ö–æ–∂–∏–µ", callback_data=f"similar_{track_id}"),
            InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥ –∫ –ø–æ–∏—Å–∫—É", callback_data="back_to_search")
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=keyboard)

# ============= –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò =============
@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
    db.add_user(message.from_user.id, message.from_user.username)
    
    welcome_text = """
üéµ *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ SoundCloud Clone Bot!*

–Ø –º–æ–≥—É –Ω–∞–π—Ç–∏ –¥–ª—è –≤–∞—Å –ª—é–±—É—é –º—É–∑—ã–∫—É –∏–∑ –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —Å–æ –≤—Å–µ–≥–æ –º–∏—Ä–∞.

*–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:*
/search - –ü–æ–∏—Å–∫ –º—É–∑—ã–∫–∏
/trending - –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ç—Ä–µ–∫–∏
/help - –ü–æ–º–æ—â—å

–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞ –∏–ª–∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è –¥–ª—è –ø–æ–∏—Å–∫–∞!
    """
    
    await message.answer(welcome_text, parse_mode="Markdown")

@dp.message(Command("search"))
async def cmd_search(message: types.Message):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã –ø–æ–∏—Å–∫–∞"""
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø–æ–∏—Å–∫–∞: /search <–Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞ –∏–ª–∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è>")
        return
    
    query = args[1]
    await message.answer(f"üîç –ò—â—É: *{query}*...", parse_mode="Markdown")
    
    # –ò—â–µ–º —Ç—Ä–µ–∫–∏
    tracks = await aggregator.aggregate_search(query, config.SEARCH_LIMIT)
    
    if not tracks:
        await message.answer("‚ùå –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü    
