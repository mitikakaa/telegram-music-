import asyncio
import sqlite3
import os
import json
import time
import hashlib
import logging
from dataclasses import dataclass
from typing import List, Dict, Optional, Tuple

import aiohttp
import aiofiles
import yt_dlp
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.types import (
    Message, CallbackQuery, InlineKeyboardMarkup, 
    InlineKeyboardButton, FSInputFile
)
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties

# ============= –õ–û–ì–ò–†–û–í–ê–ù–ò–ï =============
logging.basicConfig(level=logging.INFO)

# ============= –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø =============
@dataclass
class Config:
    # –í–ê–ñ–ù–û: –ù–∞ GitHub –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
    BOT_TOKEN: str = "8524841805:AAGnJNG8DDfOxc0Zyubzt1uEXNYe9sHLaCM"
    CACHE_DIR: str = "audio_cache"
    DB_PATH: str = "music_bot.db"
    SEARCH_LIMIT: int = 15

config = Config()
os.makedirs(config.CACHE_DIR, exist_ok=True)

# ============= –ë–ê–ó–ê –î–ê–ù–ù–´–• =============
class Database:
    def __init__(self):
        self.conn = sqlite3.connect(config.DB_PATH, check_same_thread=False)
        self.cursor = self.conn.cursor()
        self._init_db()

    def _init_db(self):
        self.cursor.execute('''CREATE TABLE IF NOT EXISTS users 
            (user_id INTEGER PRIMARY KEY, username TEXT, search_count INTEGER DEFAULT 0)''')
        self.cursor.execute('''CREATE TABLE IF NOT EXISTS search_cache 
            (query TEXT PRIMARY KEY, results TEXT, timestamp INTEGER)''')
        self.conn.commit()

    def add_user(self, user_id: int, username: str):
        self.cursor.execute('INSERT OR IGNORE INTO users (user_id, username) VALUES (?, ?)', (user_id, username))
        self.conn.commit()

    def cache_search(self, query: str, results: list):
        self.cursor.execute('INSERT OR REPLACE INTO search_cache VALUES (?, ?, ?)', 
                           (query, json.dumps(results), int(time.time())))
        self.conn.commit()

    def get_cached(self, query: str):
        self.cursor.execute('SELECT results FROM search_cache WHERE query = ? AND timestamp > ?', 
                           (query, int(time.time()) - 3600))
        res = self.cursor.fetchone()
        return json.loads(res[0]) if res else None

db = Database()

# ============= –ü–û–ò–°–ö –ò –ó–ê–ì–†–£–ó–ö–ê =============
class MusicManager:
    def __init__(self):
        self.ydl_opts = {
            'format': 'bestaudio/best',
            'quiet': True,
            'no_warnings': True,
            'extract_flat': True,
            'default_search': 'ytsearch',
        }

    async def search(self, query: str) -> List[Dict]:
        cached = db.get_cached(query)
        if cached: return cached

        ydl = yt_dlp.YoutubeDL(self.ydl_opts)
        loop = asyncio.get_event_loop()
        try:
            # –ü–æ–∏—Å–∫ —á–µ—Ä–µ–∑ YouTube (—Å–∞–º—ã–π —Å—Ç–∞–±–∏–ª—å–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫)
            info = await loop.run_in_executor(None, lambda: ydl.extract_info(f"ytsearch{config.SEARCH_LIMIT}:{query}", download=False))
            tracks = []
            for entry in info.get('entries', []):
                if entry:
                    tracks.append({
                        'id': entry['id'],
                        'title': entry.get('title', 'Unknown'),
                        'artist': entry.get('uploader', 'Unknown'),
                        'url': entry.get('webpage_url'),
                        'duration': entry.get('duration', 0)
                    })
            db.cache_search(query, tracks)
            return tracks
        except Exception as e:
            logging.error(f"Search error: {e}")
            return []

    async def download(self, track_id: str, url: str) -> Optional[str]:
        file_path = os.path.join(config.CACHE_DIR, f"{track_id}.mp3")
        if os.path.exists(file_path): return file_path

        opts = {
            'format': 'bestaudio/best',
            'outtmpl': os.path.join(config.CACHE_DIR, f"{track_id}.%(ext)s"),
            'postprocessors': [{'key': 'FFmpegExtractAudio', 'preferredcodec': 'mp3', 'preferredquality': '192'}],
            'quiet': True
        }
        try:
            with yt_dlp.YoutubeDL(opts) as ydl:
                await asyncio.get_event_loop().run_in_executor(None, lambda: ydl.download([url]))
            return file_path
        except Exception as e:
            logging.error(f"Download error: {e}")
            return None

manager = MusicManager()

# ============= –¢–ï–õ–ï–ì–†–ê–ú –ë–û–¢ =============
bot = Bot(token=config.BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()
user_sessions = {} # –í—Ä–µ–º–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞

def get_tracks_kb(user_id: int, page: int = 0) -> InlineKeyboardMarkup:
    data = user_sessions.get(user_id, [])
    per_page = 5
    start = page * per_page
    end = start + per_page
    
    buttons = []
    for i, track in enumerate(data[start:end]):
        buttons.append([InlineKeyboardButton(text=f"üéµ {track['title'][:35]}", callback_data=f"dl_{start+i}")])
    
    nav = []
    if page > 0: nav.append(InlineKeyboardButton(text="‚óÄÔ∏è", callback_data=f"pg_{page-1}"))
    nav.append(InlineKeyboardButton(text=f"{page+1}", callback_data="ignore"))
    if end < len(data): nav.append(InlineKeyboardButton(text="‚ñ∂Ô∏è", callback_data=f"pg_{page+1}"))
    
    if nav: buttons.append(nav)
    return InlineKeyboardMarkup(inline_keyboard=buttons)

# ============= –•–ï–ù–î–õ–ï–†–´ =============
@dp.message(Command("start"))
async def start(m: Message):
    db.add_user(m.from_user.id, m.from_user.username)
    await m.answer("üëã –ü—Ä–∏–≤–µ—Ç! –í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Å–Ω–∏, –∏ —è –µ–µ –Ω–∞–π–¥—É.")

@dp.message(F.text)
async def handle_search(m: Message):
    msg = await m.answer("üîç –ò—â—É —Ç—Ä–µ–∫–∏...")
    tracks = await manager.search(m.text)
    
    if not tracks:
        return await msg.edit_text("‚ùå –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
    
    user_sessions[m.from_user.id] = tracks
    await msg.edit_text(f"üé∂ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è: <b>{m.text}</b>", reply_markup=get_tracks_kb(m.from_user.id))

@dp.callback_query(F.data.startswith("pg_"))
async def paginate(clb: CallbackQuery):
    page = int(clb.data.split("_")[1])
    await clb.message.edit_reply_markup(reply_markup=get_tracks_kb(clb.from_user.id, page))
    await clb.answer()

@dp.callback_query(F.data.startswith("dl_"))
async def download(clb: CallbackQuery):
    idx = int(clb.data.split("_")[1])
    tracks = user_sessions.get(clb.from_user.id)
    if not tracks: return await clb.answer("–û—à–∏–±–∫–∞ —Å–µ—Å—Å–∏–∏")
    
    track = tracks[idx]
    await clb.answer(f"–ó–∞–≥—Ä—É–∂–∞—é: {track['title'][:20]}...")
    
    path = await manager.download(track['id'], track['url'])
    if path:
        audio = FSInputFile(path)
        await clb.message.answer_audio(audio, caption=f"‚úÖ {track['title']}\n–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: {track['artist']}")
    else:
        await clb.message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞.")

async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
        
